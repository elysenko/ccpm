#!/usr/bin/env bash
# sync-issues-to-db.sh - Sync issues from JSON to database
#
# This script reads the issues JSON file generated by /pm:analyze-feedback
# and inserts/updates the records in the PostgreSQL issues table.
#
# Usage: ./sync-issues-to-db.sh <session-name> <test-run-id>

set -euo pipefail

# Constants
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="${PROJECT_ROOT:-$(cd "${SCRIPT_DIR}/../.." && pwd)}"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m'

# Arguments
SESSION="${1:-}"
TEST_RUN_ID="${2:-}"

if [[ -z "${SESSION}" ]]; then
  echo -e "${RED}Usage: $0 <session-name> <test-run-id>${NC}"
  exit 1
fi

# File paths
ISSUES_JSON="${PROJECT_ROOT}/.claude/testing/feedback/${SESSION}-issues.json"
FEEDBACK_JSON="${PROJECT_ROOT}/.claude/testing/feedback/${SESSION}-feedback.json"

# Get database connection string from environment
get_db_conn() {
  if [[ -f "${PROJECT_ROOT}/.env" ]]; then
    set -a
    # shellcheck source=/dev/null
    source "${PROJECT_ROOT}/.env"
    set +a
  fi

  local -r host="${POSTGRES_HOST:-localhost}"
  local -r port="${POSTGRES_PORT:-5432}"
  local -r user="${POSTGRES_USER:-postgres}"
  local -r pass="${POSTGRES_PASSWORD:-}"
  local db
  db="${POSTGRES_DB:-$(basename "${PROJECT_ROOT}")}"

  echo "postgresql://${user}:${pass}@${host}:${port}/${db}"
}

# Run database query
db_query() {
  local -r query="$1"
  local conn
  conn=$(get_db_conn)
  psql "${conn}" -t -A -c "${query}" 2>/dev/null || echo ""
}

# Map JSON type to database category
map_category() {
  local type="$1"
  case "${type}" in
    bug) echo "bug" ;;
    feature_request) echo "feature_request" ;;
    infrastructure) echo "performance" ;;  # Map infrastructure to performance
    *) echo "bug" ;;  # Default to bug
  esac
}

# Sync issues from JSON to database
sync_issues() {
  if [[ ! -f "${ISSUES_JSON}" ]]; then
    echo -e "${YELLOW}Issues file not found: ${ISSUES_JSON}${NC}"
    return 0
  fi

  echo "Syncing issues from ${ISSUES_JSON}..."

  # Get test_run_id from JSON if not provided
  if [[ -z "${TEST_RUN_ID}" ]]; then
    TEST_RUN_ID=$(jq -r '.testRun // ""' "${ISSUES_JSON}")
    if [[ -z "${TEST_RUN_ID}" || "${TEST_RUN_ID}" == "null" ]]; then
      echo -e "${RED}No test_run_id provided and none found in JSON${NC}"
      return 1
    fi
  fi

  local issue_count=0
  local issue

  # Process each prioritized issue
  while IFS= read -r issue; do
    [[ -z "${issue}" || "${issue}" == "null" ]] && continue

    # Extract fields
    local issue_id title description type severity rice_score suggested_fix
    issue_id=$(echo "${issue}" | jq -r '.id // ""')
    title=$(echo "${issue}" | jq -r '.title // ""')
    description=$(echo "${issue}" | jq -r '.description // ""')
    type=$(echo "${issue}" | jq -r '.type // "bug"')
    severity=$(echo "${issue}" | jq -r '.severity // "medium"')
    rice_score=$(echo "${issue}" | jq -r '.riceScore // 0')
    suggested_fix=$(echo "${issue}" | jq -r '.suggestedFix // ""')

    # Get arrays as JSON
    local reported_by journeys_affected
    reported_by=$(echo "${issue}" | jq -c '.reportedBy // []')
    journeys_affected=$(echo "${issue}" | jq -c '.journeysAffected // []')

    # Map category
    local category
    category=$(map_category "${type}")

    # Calculate mentions
    local mentions
    mentions=$(echo "${issue}" | jq -r '.reportedBy | length // 1')

    # Escape for SQL (replace single quotes with two single quotes)
    title=$(echo "${title}" | sed "s/'/''/g")
    description=$(echo "${description}" | sed "s/'/''/g")
    suggested_fix=$(echo "${suggested_fix}" | sed "s/'/''/g")

    # Combine description with suggested fix
    local full_description="${description}"
    if [[ -n "${suggested_fix}" ]]; then
      full_description="${description}\n\n## Suggested Fix\n${suggested_fix}"
    fi
    full_description=$(echo -e "${full_description}" | sed "s/'/''/g")

    # Insert or update
    db_query "INSERT INTO issues (
      session_name, test_run_id, issue_id, title, description,
      category, severity, rice_score, mentions, journey_refs, persona_refs, status, created_at
    ) VALUES (
      '${SESSION}', '${TEST_RUN_ID}', '${issue_id}',
      '${title}', '${full_description}', '${category}',
      '${severity}', ${rice_score}, ${mentions}, '${journeys_affected}'::jsonb, '${reported_by}'::jsonb, 'open', NOW()
    ) ON CONFLICT (session_name, test_run_id, issue_id) DO UPDATE SET
      title = EXCLUDED.title,
      description = EXCLUDED.description,
      category = EXCLUDED.category,
      severity = EXCLUDED.severity,
      rice_score = EXCLUDED.rice_score,
      mentions = EXCLUDED.mentions,
      journey_refs = EXCLUDED.journey_refs,
      persona_refs = EXCLUDED.persona_refs" > /dev/null

    ((++issue_count))
    echo "  - ${issue_id}: ${title}"
  done < <(jq -c '.prioritizedIssues[]' "${ISSUES_JSON}" 2>/dev/null)

  echo -e "${GREEN}Synced ${issue_count} issues to database${NC}"
}

# Sync feedback from JSON to database
sync_feedback() {
  if [[ ! -f "${FEEDBACK_JSON}" ]]; then
    echo -e "${YELLOW}Feedback file not found: ${FEEDBACK_JSON}${NC}"
    return 0
  fi

  echo "Syncing feedback from ${FEEDBACK_JSON}..."

  # Get test_run_id from JSON if not provided
  if [[ -z "${TEST_RUN_ID}" ]]; then
    TEST_RUN_ID=$(jq -r '.testRunId // ""' "${FEEDBACK_JSON}")
    if [[ -z "${TEST_RUN_ID}" || "${TEST_RUN_ID}" == "null" ]]; then
      echo -e "${YELLOW}No test_run_id in feedback JSON${NC}"
      return 0
    fi
  fi

  local feedback_count=0
  local fb

  # Process each feedback entry
  while IFS= read -r fb; do
    [[ -z "${fb}" || "${fb}" == "null" ]] && continue

    # Extract fields
    local persona_id rating nps recommendation
    persona_id=$(echo "${fb}" | jq -r '.personaId // ""')
    rating=$(echo "${fb}" | jq -r '.overallRating // 0')
    nps=$(echo "${fb}" | jq -r '.npsScore // 0')
    recommendation=$(echo "${fb}" | jq -r '.recommendation // "maybe"')

    # Get arrays as JSON and escape single quotes for SQL
    local positives frustrations bugs feature_requests test_context
    positives=$(echo "${fb}" | jq -c '.positives // []' | sed "s/'/''/g")
    frustrations=$(echo "${fb}" | jq -c '.frustrations // []' | sed "s/'/''/g")
    bugs=$(echo "${fb}" | jq -c '.bugs // []' | sed "s/'/''/g")
    feature_requests=$(echo "${fb}" | jq -c '.featureRequests // []' | sed "s/'/''/g")
    test_context=$(echo "${fb}" | jq -c '.testContext // {}' | sed "s/'/''/g")

    # Insert or update
    db_query "INSERT INTO feedback (
      session_name, test_run_id, persona_id, overall_rating, nps_score,
      recommendation, positives, frustrations, bugs, feature_requests, test_context
    ) VALUES (
      '${SESSION}', '${TEST_RUN_ID}', '${persona_id}',
      ${rating}, ${nps}, '${recommendation}',
      '${positives}'::jsonb, '${frustrations}'::jsonb, '${bugs}'::jsonb, '${feature_requests}'::jsonb, '${test_context}'::jsonb
    ) ON CONFLICT (session_name, test_run_id, persona_id) DO UPDATE SET
      overall_rating = EXCLUDED.overall_rating,
      nps_score = EXCLUDED.nps_score,
      recommendation = EXCLUDED.recommendation,
      positives = EXCLUDED.positives,
      frustrations = EXCLUDED.frustrations,
      bugs = EXCLUDED.bugs,
      feature_requests = EXCLUDED.feature_requests" > /dev/null

    ((++feedback_count))
  done < <(jq -c '.feedback[]' "${FEEDBACK_JSON}" 2>/dev/null)

  echo -e "${GREEN}Synced ${feedback_count} feedback entries to database${NC}"
}

# Main
main() {
  echo "=== Syncing Issues and Feedback to Database ==="
  echo "Session: ${SESSION}"
  echo "Test Run: ${TEST_RUN_ID:-'(from JSON)'}"
  echo ""

  sync_issues
  sync_feedback

  echo ""
  echo "=== Sync Complete ==="
}

main
